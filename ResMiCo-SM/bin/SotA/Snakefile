rule ALE:
    """
    Running ALE on assemblies
    """
    input:
        ref = config['tmp_dir'] + \
              '{richness}/{abund_dist}/{rep}/{read_length}/{read_depth}/{assembler}/contigs_filtered.fasta',
        bam = config['tmp_dir'] + \
              'map/{richness}/{abund_dist}/{rep}/{read_length}/{read_depth}/{assembler}.bam',
        bai = config['tmp_dir'] + \
              'map/{richness}/{abund_dist}/{rep}/{read_length}/{read_depth}/{assembler}.bam.bai'
    output:
        txt = temp(config['tmp_dir'] + \
               '{richness}/{abund_dist}/{rep}/{read_length}/{read_depth}/{assembler}/ALE_results.txt'),
        gz = ale_dir + \
              '{richness}/{abund_dist}/{rep}/{read_length}/{read_depth}/{assembler}/ALE_results.txt.gz'
    params:
        params = config['params']['SotA']['ALE'],
        exe = config['pipeline']['script_folder'] + 'ALE',
        ionice = config['params']['ionice'],
        exe_empty = config['pipeline']['script_folder'] + 'is_empty.py'         
    resources:
        time = lambda wildcards, attempt: attempt * 59 * 12,
        mem_gb_pt = lambda wildcards, attempt: attempt ** 2 + 7
    log:
        log_dir + 'ALE/{richness}/{abund_dist}/{rep}/{read_length}/{read_depth}/{assembler}.log'
    benchmark:
        benchmark_dir + 'ALE/{richness}/{abund_dist}/{rep}/{read_length}/{read_depth}/{assembler}.txt'
    shell:
        """
        if [ `{params.exe_empty} {input.ref}` -eq 0 ]; then
          {params.exe} {params.params} \
            {input.bam} {input.ref} {output.txt} 2> {log} 1>&2
          ionice {params.ionice} gzip -c {output.txt} > {output.gz} 2> {log}
        else
          echo "Input empty; skipping" > {log}
          touch {output.txt} {output.gz} 2>> {log}
        fi
        """

rule VALET:
    """
    Running VALET on assemblies
    """
    input:
        ref = config['tmp_dir'] + \
              '{richness}/{abund_dist}/{rep}/{read_length}/{read_depth}/{assembler}/contigs_filtered.fasta',
    	read1 = config['tmp_dir'] + '{richness}/{abund_dist}/{rep}/{read_length}/{read_depth}/sim_reads/R1.fq',
	read2 = config['tmp_dir'] + '{richness}/{abund_dist}/{rep}/{read_length}/{read_depth}/sim_reads/R2.fq'
    output:
        sum = valet_dir + '{richness}/{abund_dist}/{rep}/{read_length}/{read_depth}/{assembler}/summary.tsv',
        sbed = valet_dir + '{richness}/{abund_dist}/{rep}/{read_length}/{read_depth}/{assembler}/summary.bed',
        ssbed = valet_dir + '{richness}/{abund_dist}/{rep}/{read_length}/{read_depth}/{assembler}/suspicious.bed',
        cbed = valet_dir + '{richness}/{abund_dist}/{rep}/{read_length}/{read_depth}/{assembler}/coverage.bed',
        bbed = valet_dir + '{richness}/{abund_dist}/{rep}/{read_length}/{read_depth}/{assembler}/breakpoints.bed'
    params:
        params = config['params']['SotA']['VALET'],
        ionice = config['params']['ionice'],
        tmp_dir = config['tmp_dir'] + \
                  'VALET/{richness}/{abund_dist}/{rep}/{read_length}/{read_depth}/{assembler}/valet_out/reference/',
        exe_empty = config['pipeline']['script_folder'] + 'is_empty.py' 
    threads:
        8
    resources:
        time = lambda wildcards, attempt: attempt * 60 * 12,
        n = lambda wildcards, threads: threads,
        mem_gb_pt = lambda wildcards, attempt: attempt ** 2 + 2
    conda:
        '../envs/valet.yaml'
    log:
        log_dir + 'VALET/{richness}/{abund_dist}/{rep}/{read_length}/{read_depth}/{assembler}.log'
    benchmark:
        benchmark_dir + 'VALET/{richness}/{abund_dist}/{rep}/{read_length}/{read_depth}/{assembler}.txt'
    shell:
        """
        export PATH=$CONDA_PREFIX/bin:$PATH
        # tmp directory
        TMPDIR=`dirname {params.tmp_dir}`
        rm -rf $TMPDIR 2> {log}

        if [ `{params.exe_empty} {input.ref}` -eq 0 ]; then
          # valet run        
          valet.py --threads {threads} \
            --assembly-names reference \
            --skip-reapr {params.params} \
            --output-dir $TMPDIR -a {input.ref} \
            -1 {input.read1} -2 {input.read2} \
            2>> {log}        

          # copying files
          ionice {params.ionice} cp -f {params.tmp_dir}/summary.tsv {output.sum} 2>> {log}
          ionice {params.ionice} cp -f {params.tmp_dir}/summary.bed {output.sbed} 2>> {log}
          ionice {params.ionice} cp -f {params.tmp_dir}/suspicious.bed {output.ssbed} 2>> {log}
          ionice {params.ionice} cp -f {params.tmp_dir}/coverage.bed {output.cbed} 2>> {log}
          ionice {params.ionice} cp -f {params.tmp_dir}/breakpoints.bed {output.bbed} 2>> {log}
        
          # removing tmp dir
          rm -rf $TMPDIR 2>> {log}
        else
          echo "Input empty; skipping" > {log}
          touch {output.sum} {output.sbed} {output.ssbed} {output.cbed} {output.bbed} 2>> {log}
        fi
        """

rule samtools_pileup:
    """
    Running metaMIC extract_features
    """
    input:
        fna = config['tmp_dir'] + \
              '{richness}/{abund_dist}/{rep}/{read_length}/{read_depth}/{assembler}/contigs_filtered.fasta',
        bam = config['tmp_dir'] + \
              'map/{richness}/{abund_dist}/{rep}/{read_length}/{read_depth}/{assembler}.bam',
        bai = config['tmp_dir'] + \
              'map/{richness}/{abund_dist}/{rep}/{read_length}/{read_depth}/{assembler}.bam.bai'
    output:
        txt = temp(config['tmp_dir'] + \
               '{richness}/{abund_dist}/{rep}/{read_length}/{read_depth}/{assembler}/pileup.txt')
    params:
        ionice = config['params']['ionice'],
        exe_empty = config['pipeline']['script_folder'] + 'is_empty.py'          
    resources:
        time = lambda wildcards, attempt: attempt * 60 * 24,
        mem_gb_pt = lambda wildcards, attempt: attempt ** 2 + 4
    log:
        log_dir + 'samtools/pileup/{richness}/{abund_dist}/{rep}/{read_length}/{read_depth}/{assembler}.log'
    benchmark:
        benchmark_dir + 'samtools/pileup/{richness}/{abund_dist}/{rep}/{read_length}/{read_depth}/{assembler}.txt'
    shell:
        """
        > {log}
        if [ `{params.exe_empty} {input.fna}` -eq 0 ]; then
          samtools mpileup -C 50 -A -f {input.fna} {input.bam} 2>> {log} | \
            awk '$3 != "N"' > {output.txt} 2>> {log}
        else
          echo "Input empty; skipping" > {log}
          touch {output.txt} 2>> {log}
        fi
        """

localrules: metaMIC_model_dl
rule metaMIC_model_dl:
    """
    Running metaMIC download_model
    """
    output:
        done = touch(metamic_dir + 'model_download.done')
    conda:
        '../envs/metaMIC.yaml'
    log:
        log_dir + 'metaMIC/model_dl/all.log'
    shell:
        """
        metaMIC download_model 2> {log} 1>&2
        touch {output.done} 2>> {log} 1>&2
        """
        
rule metaMIC_extract:
    """
    Running metaMIC extract_features
    """
    input:
        done = metamic_dir + 'model_download.done',         
        contigs = config['tmp_dir'] + \
                  '{richness}/{abund_dist}/{rep}/{read_length}/{read_depth}/{assembler}/contigs_filtered.fasta',
        pileup = config['tmp_dir'] + \
                 '{richness}/{abund_dist}/{rep}/{read_length}/{read_depth}/{assembler}/pileup.txt',
        bam = config['tmp_dir'] + \
              'map/{richness}/{abund_dist}/{rep}/{read_length}/{read_depth}/{assembler}.bam',
        bai = config['tmp_dir'] + \
              'map/{richness}/{abund_dist}/{rep}/{read_length}/{read_depth}/{assembler}.bam.bai'
    output:
        txt = temp(config['tmp_dir'] + \
                   '{richness}/{abund_dist}/{rep}/{read_length}/{read_depth}/{assembler}/' + \
                   'metaMIC/feature_matrix/window_fea_matrix.txt'),
        rb = temp(config['tmp_dir'] + \
                   '{richness}/{abund_dist}/{rep}/{read_length}/{read_depth}/{assembler}/' + \
                   'metaMIC/temp/read_breakpoint/read_breakpoint_per_base.txt')        
    params:
        params = config['params']['SotA']['metaMIC']['extract'],
        exe_empty = config['pipeline']['script_folder'] + 'is_empty.py'          
    conda:
        '../envs/metaMIC.yaml'
    threads:
        8
    resources:
        time = lambda wildcards, attempt: attempt * 60 * 24,
        n = lambda wildcards, attempt, threads: threads,
        mem_gb_pt = lambda wildcards, attempt: attempt ** 2 + 4
    log:
        log_dir + 'metaMIC/extract/{richness}/{abund_dist}/{rep}/{read_length}/{read_depth}/{assembler}.log'
    benchmark:
        benchmark_dir + 'metaMIC/extract/{richness}/{abund_dist}/{rep}/{read_length}/{read_depth}/{assembler}.txt'
    shell:
        """
        OUTDIR=`dirname {output.txt}`
        OUTDIR=`dirname $OUTDIR`
        rm -rf $OUTDIR/temp/ $OUTDIR/feature_matrix/ 2> {log}
        if [ `{params.exe_empty} {input.contigs}` -eq 0 ]; then
          metaMIC extract_feature {params.params} -t {threads} -m meta \
            --pileup {input.pileup} --bam {input.bam} \
            --contig {input.contigs} --output $OUTDIR 2>> {log}
        else
          echo "Input empty; skipping" > {log}
          touch {output.txt} {output.rb} 2>> {log}
        fi
        """

rule metaMIC_predict:
    """
    Running metaMIC predict
    """
    input:
        metamic_dir + 'model_download.done',
        contigs = config['tmp_dir'] + \
                  '{richness}/{abund_dist}/{rep}/{read_length}/{read_depth}/{assembler}/contigs_filtered.fasta',
        txt = config['tmp_dir'] + \
              '{richness}/{abund_dist}/{rep}/{read_length}/{read_depth}/{assembler}/' + \
              'metaMIC/feature_matrix/window_fea_matrix.txt',
        rb = config['tmp_dir'] + \
             '{richness}/{abund_dist}/{rep}/{read_length}/{read_depth}/{assembler}/' + \
             'metaMIC/temp/read_breakpoint/read_breakpoint_per_base.txt' 
    output:
        scr = temp(config['tmp_dir'] + \
               '{richness}/{abund_dist}/{rep}/{read_length}/{read_depth}/{assembler}/metaMIC/metaMIC_contig_score.txt'),
        txt = temp(config['tmp_dir'] + \
               '{richness}/{abund_dist}/{rep}/{read_length}/{read_depth}/{assembler}/metaMIC/anomaly_score.txt'),
        fna = temp(config['tmp_dir'] + \
               '{richness}/{abund_dist}/{rep}/{read_length}/{read_depth}/{assembler}/metaMIC/metaMIC_corrected_contigs.fa'),
        brk = temp(config['tmp_dir'] + \
               '{richness}/{abund_dist}/{rep}/{read_length}/{read_depth}/{assembler}/metaMIC/misassembly_breakpoint.txt')
    params:
        params = config['params']['SotA']['metaMIC']['predict'],
        exe_empty = config['pipeline']['script_folder'] + 'is_empty.py'          
    conda:
        '../envs/metaMIC.yaml'
    resources:
        time = lambda wildcards, attempt: attempt * 60 * 12,
        mem_gb_pt = lambda wildcards, attempt: attempt ** 3 * 2 + 8
    log:
        log_dir + 'metaMIC/predict/{richness}/{abund_dist}/{rep}/{read_length}/{read_depth}/{assembler}.log'
    benchmark:
        benchmark_dir + 'metaMIC/predict/{richness}/{abund_dist}/{rep}/{read_length}/{read_depth}/{assembler}.txt'
    shell:
        """
        OUTDIR=`dirname {output.txt}`
        if [ `{params.exe_empty} {input.contigs}` -eq 0 ]; then
          metaMIC predict {params.params} -m meta \
            --contig {input.contigs} --output $OUTDIR 2> {log} 1>&2
        else
          echo "Input empty; skipping" > {log}
          touch {output.scr} {output.txt} {output.fna} {output.brk}
        fi
        """

localrules: metaMIC_copy
rule metaMIC_copy:
    """
    Copying final metaMIC results
    """
    input:
        scr = config['tmp_dir'] + \
              '{richness}/{abund_dist}/{rep}/{read_length}/{read_depth}/{assembler}/metaMIC/metaMIC_contig_score.txt',
        fna = config['tmp_dir'] + \
              '{richness}/{abund_dist}/{rep}/{read_length}/{read_depth}/{assembler}/metaMIC/metaMIC_corrected_contigs.fa',
        brk = config['tmp_dir'] + \
              '{richness}/{abund_dist}/{rep}/{read_length}/{read_depth}/{assembler}/metaMIC/misassembly_breakpoint.txt',
        txt = config['tmp_dir'] + \
              '{richness}/{abund_dist}/{rep}/{read_length}/{read_depth}/{assembler}/metaMIC/anomaly_score.txt',
        mtx = config['tmp_dir'] + '{richness}/{abund_dist}/{rep}/{read_length}/{read_depth}/{assembler}/' + \
              'metaMIC/feature_matrix/window_fea_matrix.txt',
        rbb = config['tmp_dir'] + '{richness}/{abund_dist}/{rep}/{read_length}/{read_depth}/{assembler}/' + \
              'metaMIC/temp/read_breakpoint/read_breakpoint_per_base.txt'
    output:
        scr = metamic_dir + '{richness}/{abund_dist}/{rep}/{read_length}/{read_depth}/{assembler}/' + \
              'metaMIC/metaMIC_contig_score.txt.gz',
        txt = metamic_dir + '{richness}/{abund_dist}/{rep}/{read_length}/{read_depth}/{assembler}/' + \
              'metaMIC/anomaly_score.txt.gz',
        fna = metamic_dir + '{richness}/{abund_dist}/{rep}/{read_length}/{read_depth}/{assembler}/' + \
              'metaMIC/metaMIC_corrected_contigs.fa.gz',
        brk = metamic_dir + '{richness}/{abund_dist}/{rep}/{read_length}/{read_depth}/{assembler}/' + \
              'metaMIC/misassembly_breakpoint.txt.gz',
        mtx = metamic_dir + '{richness}/{abund_dist}/{rep}/{read_length}/{read_depth}/{assembler}/' + \
              'metaMIC/feature_matrix/window_fea_matrix.txt.gz',
        rbb = metamic_dir + '{richness}/{abund_dist}/{rep}/{read_length}/{read_depth}/{assembler}/' + \
              'metaMIC/temp/read_breakpoint/read_breakpoint_per_base.txt.gz'
    params:
        ionice = config['params']['ionice']
    log:
        log_dir + 'metaMIC/copy/{richness}/{abund_dist}/{rep}/{read_length}/{read_depth}/{assembler}.log'
    shell:
        """
        ionice {params.ionice} gzip -c {input.scr} > {output.scr} 2>> {log}
        ionice {params.ionice} gzip -c {input.fna} > {output.fna} 2>> {log}
        ionice {params.ionice} gzip -c {input.brk} > {output.brk} 2>> {log}
        ionice {params.ionice} gzip -c {input.txt} > {output.txt} 2> {log}
        ionice {params.ionice} gzip -c {input.mtx} > {output.mtx} 2>> {log}
        ionice {params.ionice} gzip -c {input.rbb} > {output.rbb} 2>> {log}
        """
